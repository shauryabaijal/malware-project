#include <chrono>
#include <fstream>
#include <iostream>
#include <string>
#include <thread>
#include <sys/stat.h>
#include <termios.h>
#include "SecureShellManager.h"

void select_loop(ssh_session session,ssh_channel channel, std::string& out, std::string& err, unsigned int timeout_seconds){
    fd_set fds;
    struct timeval timeout;
    char buffer[4096];
    /* channels will be set to the channels to poll.
     * outchannels will contain the result of the poll
     */
    ssh_channel channels[2], outchannels[2];
    int lus;
    int eof=0;
    int maxfd;
    int ret;
    
    auto _start = std::chrono::steady_clock::now();
    auto _end = std::chrono::steady_clock::now();
    
    auto _diff = std::chrono::duration_cast<std::chrono::seconds>(_end - _start);
    
    while(channel){
        do{
            FD_ZERO(&fds);
            if(!eof)
                FD_SET(0,&fds);
            timeout.tv_sec=1;
            timeout.tv_usec=0;
            FD_SET(ssh_get_fd(session),&fds);
            maxfd=ssh_get_fd(session)+1;
            channels[0]=channel; // set the first channel we want to read from
            channels[1]=NULL;
            ret=ssh_select(channels,outchannels,maxfd,&fds,&timeout);
            if(ret==EINTR)
            {
                _end = std::chrono::steady_clock::now();
                _diff = std::chrono::duration_cast<std::chrono::seconds>(_end - _start);
                
                if (timeout_seconds > 0 && _diff.count() >= timeout_seconds)
                    return;
                else
                    continue;
            }
            if(FD_ISSET(0,&fds)){
                lus=read(0,buffer,sizeof(buffer));
                if(lus)
                    ssh_channel_write(channel,buffer,lus);
                else {
                    eof=1;
                    ssh_channel_send_eof(channel);
                }
            }
            if(channel && ssh_channel_is_closed(channel)){
                ssh_channel_free(channel);
                channel=NULL;
                channels[0]=NULL;
            }
            if(outchannels[0]){
                while(channel && ssh_channel_is_open(channel) && ssh_channel_poll(channel,0)!=0){
                    lus=ssh_channel_read(channel,buffer,sizeof(buffer),0);
                    if(lus==-1){
                        fprintf(stderr, "Error reading channel: %s\n",
                                ssh_get_error(session));
                        return;
                    }
                    if(lus==0){
                        ssh_channel_free(channel);
                        channel=channels[0]=NULL;
                    } else {
                        out.append(buffer, lus);
                    }
                    
                    _end = std::chrono::steady_clock::now();
                    _diff = std::chrono::duration_cast<std::chrono::seconds>(_end - _start);
                
                    if (timeout_seconds > 0 && _diff.count() >= timeout_seconds)
                    {
                        ssh_channel_free(channel);
                        return;
                    }
                    else
                        continue;
                }
                while(channel && ssh_channel_is_open(channel) && ssh_channel_poll(channel,1)!=0){ /* stderr */
                    lus=ssh_channel_read(channel,buffer,sizeof(buffer),1);
                    if(lus==-1){
                        fprintf(stderr, "Error reading channel: %s\n",
                                ssh_get_error(session));
                        return;
                    }
                    if(lus==0){
                        ssh_channel_free(channel);
                        channel=channels[0]=NULL;
                    } else {
                        err.append(buffer, lus);
                    }
                    
                    _end = std::chrono::steady_clock::now();
                    _diff = std::chrono::duration_cast<std::chrono::seconds>(_end - _start);
                
                    if (timeout_seconds > 0 && _diff.count() >= timeout_seconds)
                    {
                        ssh_channel_free(channel);
                        return;
                    }
                    else
                        continue;
                }
            }
            if(channel && ssh_channel_is_closed(channel)){
                ssh_channel_free(channel);
                channel=NULL;
            }
            
            _end = std::chrono::steady_clock::now();
            _diff = std::chrono::duration_cast<std::chrono::seconds>(_end - _start);
                
            if (timeout_seconds > 0 && _diff.count() >= timeout_seconds)
                return;
        } while (ret==EINTR || ret==SSH_EINTR);
    }
    
    _end = std::chrono::steady_clock::now();
    _diff = std::chrono::duration_cast<std::chrono::seconds>(_end - _start);
                
    if (timeout_seconds > 0 && _diff.count() >= timeout_seconds)
        return;
    else if (timeout_seconds > 0)
        std::this_thread::sleep_for(std::chrono::seconds(timeout_seconds - _diff.count()));
}

SecureShellManager::SecureShellManager(std::string host, int port) {
    this->host = host;
    this->port = port;

    session = nullptr;
    hash = nullptr;
}

SecureShellManager::~SecureShellManager() {
    ssh_disconnect(session);
    ssh_free(session);

    if (server_pubkey != nullptr)
        ssh_key_free(server_pubkey);

    if (hash != nullptr)
        ssh_clean_pubkey_hash(&hash);
}

int SecureShellManager::connect(std::string username, std::string password) {
    session = ssh_new();
    if (session == nullptr)
        return -1;

    int verbosity = SSH_LOG_NOLOG;
    ssh_options_set(session, SSH_OPTIONS_HOST, host.c_str());
    ssh_options_set(session, SSH_OPTIONS_LOG_VERBOSITY, &verbosity);
    ssh_options_set(session, SSH_OPTIONS_PORT, &port);
	ssh_options_parse_config(session, NULL);

    int return_code = ssh_connect(session);

    if (return_code != SSH_OK) {
        std::cerr << "Error connecting to [" << host << ":" << port << "]: "
                  << ssh_get_error_code(session) << std::endl;
        return -2;
    }

    return_code = ssh_get_server_publickey(session, &server_pubkey);

    if (return_code < 0)
        return -3;

    ssh_get_publickey_hash(server_pubkey,SSH_PUBLICKEY_HASH_SHA1, &hash, &hash_length);
    enum ssh_known_hosts_e state = ssh_session_is_known_server(session);

    return_code = ssh_userauth_password(session, username.c_str(), password.c_str());

    if (return_code == SSH_AUTH_SUCCESS)
        std::cout << "SSH authentication successful" << std::endl;

    return 0;
}

int SecureShellManager::executeRemoteCommand(std::string command, std::string& out, std::string& err,
        unsigned int timeout_seconds, std::string sudo_password) {
    ssh_channel channel;
    int rc;
    char buffer_out[256];
    char buffer_err[256];
    int nbytes_out, nbytes_err;

    channel = ssh_channel_new(session);
    if (channel == NULL)
        return SSH_ERROR;

    rc = ssh_channel_open_session(channel);
    if (rc != SSH_OK)
    {
        ssh_channel_free(channel);
        return rc;
    }

    rc = ssh_channel_request_exec(channel, command.c_str());
    if (rc != SSH_OK)
    {
		std::cerr << "EXEC Error: " << ssh_get_error(session) << std::endl;
        ssh_channel_close(channel);
        ssh_channel_free(channel);
        return rc;
    }

    if (!sudo_password.empty()) {
        const char ret_key = '\n';
        ssh_channel_write(channel, sudo_password.c_str(), sudo_password.length());
        ssh_channel_write(channel, &ret_key, sizeof(ret_key));
    }
    
    out = "";
    err = "";
    
    if (timeout_seconds == 10)
    {
        select_loop(session, channel, out, err, timeout_seconds);
        
        std::cout << "Output length: " << out.length() << " Stderr length: " << err.length() << std::endl;
        
        return SSH_OK;
    }
    else
    {
        std::this_thread::sleep_for(std::chrono::seconds(timeout_seconds));
        nbytes_out = ssh_channel_read_nonblocking(channel, buffer_out, sizeof(buffer_out), 0);
        nbytes_err = ssh_channel_read_nonblocking(channel, buffer_err, sizeof(buffer_out), 1);
        
        while (nbytes_out > 0)
        {
            out.append(buffer_out, nbytes_out);
            nbytes_out = ssh_channel_read_nonblocking(channel, buffer_out, sizeof(buffer_out), 0);
        }

        while (nbytes_err > 0)
        {
            out.append(buffer_err, nbytes_err);
            nbytes_err = ssh_channel_read_nonblocking(channel, buffer_err, sizeof(buffer_err), 1);
        }

        if (out.length() == 0)
        {
            std::cerr << "Is channel EOF:" << ssh_channel_is_eof(channel) << std::endl;
            std::cerr << "Is channel open: " << ssh_channel_is_open(channel) << std::endl;
            std::cerr << "[Output Error]: No output captured for (" << command
                    << ") with timeout of " << timeout_seconds << std::endl;
        }

        if (err.length() == 0)
        {
            std::cerr << "[STDERR Error]: No stderr captured for (" << command
                    << ") with timeout of " << timeout_seconds << std::endl;
        }

        if (nbytes_out < 0 || nbytes_err < 0)
        {
            ssh_channel_close(channel);
            ssh_channel_free(channel);
            return SSH_ERROR;
        }
    }

    ssh_channel_send_eof(channel);
    ssh_channel_close(channel);
    ssh_channel_free(channel);

    return SSH_OK;
}

int SecureShellManager::uploadFile(std::string path, std::string filename, const std::string &data) {
    ssh_scp scp;
    int rc;
    scp = ssh_scp_new(session, SSH_SCP_WRITE | SSH_SCP_RECURSIVE, path.c_str());
     if (scp == NULL)
     {
         std::cerr << "SCP Error: " << ssh_get_error(session) << std::endl;
         return SSH_ERROR;
     }

     rc = ssh_scp_init(scp);
     if (rc != SSH_OK)
     {
         std::cerr << "SCP Error: " << ssh_get_error(session) << std::endl;
         ssh_scp_free(scp);
         return rc;
     }

     rc = ssh_scp_push_file(scp, filename.c_str(), data.length(), S_IRUSR | S_IWUSR);
     if (rc != SSH_OK)
     {
         std::cerr << "SCP Error: " << ssh_get_error(session) << std::endl;
         ssh_scp_close(scp);
         ssh_scp_free(scp);
         return rc;
     }

     rc = ssh_scp_write(scp, data.c_str(), data.length());
     if (rc != SSH_OK)
     {
         std::cerr << "SCP Error: " << ssh_get_error(session) << std::endl;
         ssh_scp_close(scp);
         ssh_scp_free(scp);
         return rc;
     }

     ssh_scp_close(scp);
     ssh_scp_free(scp);
     return SSH_OK;
}

int SecureShellManager::downloadFile(std::string remote_path, std::string local_path) {
    ssh_scp scp;
    int rc;

    scp = ssh_scp_new(session, SSH_SCP_READ, remote_path.c_str());
    if (scp == NULL)
    {
        std::cerr << "SCP Error: " << ssh_get_error(session) << std::endl;
        return SSH_ERROR;
    }

    rc = ssh_scp_init(scp);
    if (rc != SSH_OK)
    {
        std::cerr << "SCP Error: " << ssh_get_error(session) << std::endl;
        ssh_scp_free(scp);
        return SSH_ERROR;
    }

    rc = ssh_scp_pull_request(scp);
    if (rc != SSH_SCP_REQUEST_NEWFILE)
    {
        std::cerr << "SCP Error: " << ssh_get_error(session) << std::endl;
        ssh_scp_close(scp);
        ssh_scp_free(scp);
        return SSH_ERROR;
    }

    int size = ssh_scp_request_get_size(scp);

    char *buffer = new char[size];
    if (buffer == nullptr)
    {
        std::cerr << "Cannot allocate buffer" << std::endl;
        ssh_scp_close(scp);
        ssh_scp_free(scp);
        return SSH_ERROR;
    }

    rc = ssh_scp_read(scp, buffer, size);
    if (rc == SSH_ERROR)
    {
        std::cerr << "SCP Error: " << ssh_get_error(session) << std::endl;
        ssh_scp_close(scp);
        ssh_scp_free(scp);
        return SSH_ERROR;
    }

    std::ofstream file(local_path, std::ios::binary);
    file.write(buffer, size);
    file.close();
    delete[] buffer;

    ssh_scp_close(scp);
    ssh_scp_free(scp);
    return SSH_OK;
}

InteractiveShell SecureShellManager::getInteractiveShell()
{
    InteractiveShell shell(session);
    return shell;
}

InteractiveShell::InteractiveShell(ssh_session session) {
    this->session = session;
    channel = NULL;
}

int InteractiveShell::initialize(std::string command)
{
    channel = ssh_channel_new(session);
    int rc;
    if (channel == NULL)
    {
        return SSH_ERROR;
    }

    rc = ssh_channel_open_session(channel);
    if (rc != SSH_OK)
    {
        ssh_channel_free(channel);
        channel = NULL;
        return rc;
    }

    rc = ssh_channel_request_pty(channel);
    if (rc != SSH_OK)
    {
        ssh_channel_free(channel);
        channel = NULL;
        return rc;
    }

    ssh_channel_change_pty_size(channel, 80, 40);

    rc = ssh_channel_request_shell(channel);
    if (rc != SSH_OK)
    {
        ssh_channel_free(channel);
        channel = NULL;
        return rc;
    }

    return rc;
}

void InteractiveShell::close_current_channel()
{
    if (channel != NULL)
    {
        ssh_channel_close(channel);
        ssh_channel_free(channel);
        channel = NULL;
    }
}

int InteractiveShell::write_to_channel(std::string data)
{
    if (ssh_channel_is_closed(channel))
    {
        std::cerr << "Channel has been closed" << std::endl;
        return -1;
    }
    int rc = ssh_channel_write(channel, data.c_str(), data.length());
    return rc;
}

int InteractiveShell::read_from_channel(std::string &buffer_out, std::string& buffer_err)
{
    int rc = 0;
    select_loop(session, channel, buffer_out, buffer_err, 1);
    return rc;
}