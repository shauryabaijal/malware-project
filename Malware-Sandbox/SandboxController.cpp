//
// Created by adhokshajmishra on 29/7/20.
//

#include <chrono>
#include <ctime>
#include <iostream>
#include <filesystem>
#include <fstream>
#include <mutex>
#include <thread>

#include "SandboxController.h"
#include "SecureShellManager.h"

std::mutex interim_mutex;
std::string interim_out = "", interim_err = "";
bool stopInterimExecution = false;
bool hasInterimStopped = false;

void replaceAll(std::string &str, const std::string &from, const std::string &to)
{
    if (from.empty())
        return;
    size_t start_pos =0;

    while((start_pos = str.find(from, start_pos)) != std::string::npos)
    {
        str.replace(start_pos, from.length(), to);
        start_pos += to.length();
    }
}

int RunInterimExec(VMConfig vm_config, sandbox_command cmd)
{
    SecureShellManager ssh(vm_config.ip_address, vm_config.port);
    ssh.connect(vm_config.username, vm_config.password);

    std::string data_out, data_err;

    bool runLoop = true;

    if (cmd.isSudo && !vm_config.is_sudo) {
        std::cerr << "[Sandbox Interim-exec] Error: cannot execute command ("
                  << cmd.command << "). sudo not allowed in configuration" << std::endl;

        std::lock_guard<std::mutex> guard(interim_mutex);
        hasInterimStopped = true;
        return -1;
    }

    while (runLoop)
    {
        {
            std::lock_guard<std::mutex> guard(interim_mutex);
            runLoop = !stopInterimExecution;
        }

        if (cmd.isSudo)
        {
            std::string command = "sudo ";
            command.append(cmd.command);

            std::cout << "[*] step : " << command << std::endl;
            if (vm_config.is_sudo_password)
                ssh.executeRemoteCommand(command, data_out, data_err, cmd.interval, vm_config.sudo_password);
            else
                ssh.executeRemoteCommand(command, data_out, data_err, cmd.interval);
        } else
        {
            ssh.executeRemoteCommand(cmd.command, data_out, data_err, cmd.interval);
        }

        {
            std::lock_guard<std::mutex> guard(interim_mutex);

            interim_out.append("\n---==[ INTERIM STDOUT BEGIN ]==---\n");
            interim_out.append(data_out);
            interim_out.append("\n---==[ INTERIM STDOUT END ]==---\n");

            interim_err.append("\n---==[ INTERIM STDERR BEGIN ]==---\n");
            interim_err.append(data_err);
            interim_err.append("\n---==[ INTERIM STDERR END ]==---\n");
        }
    }

    std::lock_guard<std::mutex> guard(interim_mutex);
    hasInterimStopped = true;

    return 0;
}

SandboxController::SandboxController(VMConfig vm_config, SandboxConfig sandbox_config, ExecutionConfig exec_config) {
    this->vm_config = vm_config;
    this->exec_config = exec_config;
    this->sandbox_config = sandbox_config;
}

SandboxController::~SandboxController() {
}

void SandboxController::interim_exec() {
    std::thread t(RunInterimExec, vm_config, sandbox_config.interim_exec);
    t.detach();
}

void SandboxController::runOneSample(std::filesystem::path sample, bool container, bool vmcontrol) {

    time_t exec_start = time(NULL);
    tm* start_tm = gmtime(&exec_start);

    char start_buff[100], end_buff[100];
    strftime(start_buff, sizeof(start_buff), "%Y-%m-%d %H:%M:%S", start_tm);

    if (vmcontrol)
    {
        manager.stopvm(vm_config.vm_name);
        manager.restorevm(vm_config.vm_name, vm_config.snapshot_name);
        manager.startvm(vm_config.vm_name, VBoxUIType::Headless);

        std::this_thread::sleep_for(std::chrono::seconds(2));
    }

    SecureShellManager ssh(vm_config.ip_address, vm_config.port);
    ssh.connect(vm_config.username, vm_config.password);

    std::ifstream file(sample.string(), std::ios::binary);
    std::string data_out = "", data_err = "", command = "";
    data_out.assign(std::istreambuf_iterator<char>(file), std::istreambuf_iterator<char>());
    std::cout << "Uploading sample: " << sample.filename().string() << std::endl;

    while(ssh.uploadFile(vm_config.upload_path, sample.filename().string(), data_out) != SSH_OK)
    {
        std::cout << "Re-attempting file upload after 2 seconds" << std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(2));
    }

    file.close();

    data_out.clear();

    command = "cd ";
    command.append(vm_config.upload_path);
    command.append(" && chmod +x ./");
    command.append(sample.filename().string());
    ssh.executeRemoteCommand(command, data_out, data_err, 0);

    // our sample is ready for a run. Pre-exec steps must be done here.
    std::cout << "Running pre-exec steps " << std::endl;
    for (sandbox_command cmd : sandbox_config.pre_exec)
    {
        if (cmd.isSudo && !vm_config.is_sudo) {
            std::cerr << "[Sandbox Pre-exec] Error: cannot execute command ("
                      << cmd.command << "). sudo not allowed in configuration" << std::endl;
            continue;
        }

        if (cmd.isSudo)
        {
            std::string command = "sudo ";
            command.append(cmd.command);

            std::cout << "[*] step : " << command << std::endl;
            if (vm_config.is_sudo_password)
                ssh.executeRemoteCommand(command, data_out, data_err, 1, vm_config.sudo_password);
            else
                ssh.executeRemoteCommand(command, data_out, data_err, 1);
        } else
        {
            std::cout << "[*] step : " << command << std::endl;
            ssh.executeRemoteCommand(cmd.command, data_out, data_err, 1);
        }
    }

    /*
     * pre-execution step is complete. We need to start interim-exec handler thread right before running the sample,
     * otherwise we will be waiting for its execution without having a chance to run interim-exec.
     */

    if (sandbox_config.interim_exec.interval >= 0 && sandbox_config.interim_exec.command != "")
    {
        std::cout << "Launching interim-exec..." << std::endl;
        interim_exec();
    }

    std::cout << "Running sample.." << std::endl;

    if (container)
    {
        SecureShellManager ssh2(vm_config.ip_address, vm_config.port);
        ssh2.connect(vm_config.username, vm_config.password);
        InteractiveShell shell = ssh2.getInteractiveShell();
        shell.initialize("");

        data_out.clear();
        data_err.clear();

        std::string out, err;

        shell.write_to_channel(std::string("sudo docker run -it -v ") + vm_config.upload_path + ":/data uptycs_sandbox \n");
        std::this_thread::sleep_for(std::chrono::seconds(1));
        shell.read_from_channel(data_out, data_err);
        shell.write_to_channel(std::string("/data/") + sample.filename().string() + " \n");
        std::this_thread::sleep_for(std::chrono::seconds(60));
        shell.read_from_channel(out, err);
        data_out.append(out);
        data_err.append(err);
    }
    else
    {
        if (vm_config.is_sudo)
        {
            std::string command = "cd ";
            command.append(vm_config.upload_path);
            command.append(" && sudo ./");
            command.append(sample.filename().string());

            if (vm_config.is_sudo_password)
                ssh.executeRemoteCommand(command, data_out, data_err, 0, vm_config.sudo_password);
            else
                ssh.executeRemoteCommand(command, data_out, data_err, 60);
        }
        else
        {
            std::string command = "cd ";
            command.append(vm_config.upload_path);
            command.append(" && ./");
            command.append(sample.filename().string());
            ssh.executeRemoteCommand(command, data_out, data_err, 60);
        }
    }

    /*
     * stop the interim-exec
     */

    {
        std::lock_guard<std::mutex> guard(interim_mutex);
        stopInterimExecution = true;
    }

    std::cout << "---==[ STDOUT START ]==---" << std::endl;
    std::cout << data_out << std::endl;
    std::cout << "---==[ STDOUT STOP ]==---" << std::endl;

    std::cout << "---==[ STDERR START ]==---" << std::endl;
    std::cout << data_err << std::endl;
    std::cout << "---==[ STDERR STOP ]==---" << std::endl;

    std::string stdout_filename = sandbox_config.execution_ouput;
    std::string stderr_filename = sandbox_config.execution_ouput;
    std::string detection_output = sandbox_config.execution_ouput;

    replaceAll(stdout_filename, "{%exe_name%}", sample.filename().string());
    replaceAll(stderr_filename, "{%exe_name%}", sample.filename().string());
    replaceAll(detection_output, "{%exe_name%}", sample.filename().string());
    replaceAll(stdout_filename, "{%channel%}", "stdout");
    replaceAll(stderr_filename, "{%channel%}", "stderr");
    replaceAll(detection_output, "{%channel%}", "detection");

    std::ofstream stdoutfile(stdout_filename, std::ios::binary);
    std::ofstream stderrfile(stderr_filename, std::ios::binary);

    stdoutfile.write(data_out.c_str(), data_out.length());
    stderrfile.write(data_err.c_str(), data_err.length());

    stdoutfile.close();
    stderrfile.close();

    {
        std::lock_guard<std::mutex> guard(interim_mutex);

        if (sandbox_config.interim_output.empty())
        {
            std::cout << "---==[ INTERIM START ]==---" << std::endl;
            std::cout << interim_out << std::endl;
            std::cout << interim_err << std::endl;
            std::cout << "---==[ INTERIM STOP ]==---" << std::endl;
        }
        else
        {
            std::string filename = sandbox_config.interim_output;
            std::string marker = "\n---==[ INTERIM ERROR ]==---\n";
            replaceAll(filename, "{%exe_name%}", sample.filename().string());

            std::ofstream outfile(filename, std::ios::binary);
            outfile.write(interim_out.c_str(), interim_out.length());
            outfile.write(marker.c_str(), marker.length());
            outfile.write(interim_err.c_str(), interim_err.length());
            outfile.close();
        }
    }

    // our sample has been run, and outputs have been captured. Post-exec steps must be done here.
    std::cout << "Running post-exec steps " << std::endl;
    for (sandbox_command cmd : sandbox_config.post_exec)
    {
        if (cmd.isSudo && !vm_config.is_sudo) {
            std::cerr << "[Sandbox Pre-exec] Error: cannot execute command ("
                      << cmd.command << "). sudo not allowed in configuration" << std::endl;
            continue;
        }

        if (cmd.isSudo)
        {
            std::string command = "sudo ";
            command.append(cmd.command);

            std::cout << "[*] step : " << command << std::endl;
            if (vm_config.is_sudo_password)
                ssh.executeRemoteCommand(command, data_out, data_err, 1, vm_config.sudo_password);
            else
                ssh.executeRemoteCommand(command, data_out, data_err, 1);
        } else
        {
            std::cout << "[*] step : " << command << std::endl;
            ssh.executeRemoteCommand(cmd.command, data_out, data_err, 1);
        }
    }

    if (vmcontrol)
        manager.stopvm(vm_config.vm_name);

    time_t exec_end = time(NULL);
    tm* end_tm = gmtime(&exec_end);
    strftime(end_buff, sizeof(end_buff), "%Y-%m-%d %H:%M:%S", end_tm);
}
